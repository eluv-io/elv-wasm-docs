<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="elvwasm contains and collects the bitcode extension API for the Eluvio content fabric.  The library is intended to be built as wasm and the resultant part uploaded to the content fabric. The main entry point for each client module is implemented by jpc which automatically creates and dispatches requests to the BitcodeContext  Example"><title>elvwasm - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="elvwasm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (22f247c6f 2023-03-13)" data-search-js="search-d1bc581867fd0849.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" data-theme-light-css="light-db279b6232be9c13.css" data-theme-dark-css="dark-cf923f49f397b216.css" data-theme-ayu-css="ayu-be46fdc453a55015.css" ></div><script src="../static.files/storage-9184409068f70b79.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f5a2577c5297a973.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../elvwasm/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../elvwasm/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate elvwasm</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 1.0.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">elvwasm</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/elvwasm/lib.rs.html#1-413">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>elvwasm contains and collects the bitcode extension API for the Eluvio content fabric. <br>
The library is intended to be built as wasm and the resultant part uploaded to the content fabric.
The main entry point for each client module is implemented by <a href="fn.jpc.html" title="fn elvwasm::jpc">jpc</a> which automatically creates and dispatches
requests to the <a href="bccontext/struct.BitcodeContext.html" title="struct elvwasm::bccontext::BitcodeContext">BitcodeContext</a> <br>
Example</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="kw">extern crate </span>elvwasm;
  <span class="kw">extern crate </span>serde_json;
  <span class="kw">use </span>serde_json::json;

  <span class="kw">use </span>elvwasm::{implement_bitcode_module, jpc, register_handler, BitcodeContext, ErrorKinds};

  <span class="macro">implement_bitcode_module!</span>(<span class="string">&quot;proxy&quot;</span>, do_proxy);

  <span class="kw">fn </span>do_proxy(bcc: <span class="kw-2">&amp;mut </span>elvwasm::BitcodeContext) -&gt; CallResult {
      <span class="kw">let </span>http_p = <span class="kw-2">&amp;</span>bcc.request.params.http;
      <span class="kw">let </span>qp = <span class="kw-2">&amp;</span>http_p.query;
      bcc.log_debug(<span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;In DoProxy hash={} headers={:#?} query params={qp:#?}&quot;</span>,<span class="kw-2">&amp;</span>bcc.request.q_info.hash, <span class="kw-2">&amp;</span>http_p.headers))<span class="question-mark">?</span>;
      <span class="kw">let </span>res = bcc.sqmd_get_json(<span class="string">&quot;/request_parameters&quot;</span>)<span class="question-mark">?</span>;
      <span class="kw">let </span><span class="kw-2">mut </span>meta_str: String = <span class="kw">match </span>String::from_utf8(res){
        <span class="prelude-val">Ok</span>(m) =&gt; m,
        <span class="prelude-val">Err</span>(e) =&gt; {<span class="kw">return </span>bcc.make_error_with_kind(ErrorKinds::Invalid(<span class="macro">format!</span>(<span class="string">&quot;failed to parse request params err = {e}&quot;</span>)))}
      };
      meta_str = meta_str.replace(<span class="string">&quot;${API_KEY}&quot;</span>, <span class="kw-2">&amp;</span>qp[<span class="string">&quot;API_KEY&quot;</span>][<span class="number">0</span>].to_string()).
        replace(<span class="string">&quot;${QUERY}&quot;</span>, <span class="kw-2">&amp;</span>qp[<span class="string">&quot;QUERY&quot;</span>][<span class="number">0</span>].to_string()).
        replace(<span class="string">&quot;${CONTEXT}&quot;</span>, <span class="kw-2">&amp;</span>qp[<span class="string">&quot;CONTEXT&quot;</span>][<span class="number">0</span>].to_string());
      bcc.log_debug(<span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;MetaData = {}&quot;</span>, <span class="kw-2">&amp;</span>meta_str))<span class="question-mark">?</span>;
      <span class="kw">let </span>req:serde_json::Map&lt;String,serde_json::Value&gt; = <span class="kw">match </span>serde_json::from_str::&lt;serde_json::Map&lt;String,serde_json::Value&gt;&gt;(<span class="kw-2">&amp;</span>meta_str){
        <span class="prelude-val">Ok</span>(m) =&gt; m,
        <span class="prelude-val">Err</span>(e) =&gt; <span class="kw">return </span>bcc.make_error_with_kind(ErrorKinds::Invalid(<span class="macro">format!</span>(<span class="string">&quot;serde_json::from_str failed error = {e}&quot;</span>))),
      };
      <span class="kw">let </span>proxy_resp =  bcc.proxy_http(<span class="prelude-val">Some</span>(<span class="macro">json!</span>({<span class="string">&quot;request&quot;</span>: req})))<span class="question-mark">?</span>;
      <span class="kw">let </span>proxy_resp_json:serde_json::Value = serde_json::from_str(std::str::from_utf8(<span class="kw-2">&amp;</span>proxy_resp).unwrap_or(<span class="string">&quot;{}&quot;</span>))<span class="question-mark">?</span>;
      <span class="kw">let </span>client_response = serde_json::to_vec(<span class="kw-2">&amp;</span>proxy_resp_json[<span class="string">&quot;result&quot;</span>])<span class="question-mark">?</span>;
      <span class="kw">let </span>id = <span class="kw-2">&amp;</span>bcc.request.id;
      bcc.callback(<span class="number">200</span>, <span class="string">&quot;application/json&quot;</span>, client_response.len())<span class="question-mark">?</span>;
      bcc.write_stream(<span class="string">&quot;fos&quot;</span>, <span class="kw-2">&amp;</span>client_response)<span class="question-mark">?</span>;
      bcc.make_success_json(<span class="kw-2">&amp;</span><span class="macro">json!</span>(
        {
            <span class="string">&quot;headers&quot; </span>: <span class="string">&quot;application/json&quot;</span>,
            <span class="string">&quot;body&quot; </span>: <span class="string">&quot;SUCCESS&quot;</span>,
            <span class="string">&quot;result&quot; </span>: <span class="number">0</span>,
        }))
  }</code></pre></div>
<p>To Build binaries <br>
<em>cargo build –all –features “host-wasm”</em> <br>
To Build samples <br>
<em>cd samples</em> <br>
<em>cargo build –target wasm32-unknown-unknown</em> <br>
<br>
test <br>
<em>target/debug/mock ./samples/target/wasm32-unknown-unknown/debug/deps/rproxy.wasm ./samples/fabric.json</em></p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name"><code>pub use self::<a class="mod" href="bccontext/index.html" title="mod elvwasm::bccontext">bccontext</a>::*;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="bccontext_core/index.html" title="mod elvwasm::bccontext_core">bccontext_core</a>::*;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="bccontext_error/index.html" title="mod elvwasm::bccontext_error">bccontext_error</a>::*;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="bccontext_ext/index.html" title="mod elvwasm::bccontext_ext">bccontext_ext</a>::*;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="bccontext_search/index.html" title="mod elvwasm::bccontext_search">bccontext_search</a>::*;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="bccontext_struct/index.html" title="mod elvwasm::bccontext_struct">bccontext_struct</a>::*;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="bccontext/index.html" title="mod elvwasm::bccontext">bccontext</a></div></li><li><div class="item-name"><a class="mod" href="bccontext_core/index.html" title="mod elvwasm::bccontext_core">bccontext_core</a></div><div class="desc docblock-short">Context core is a logical separation of portions of the BitcodeContext that result in calls to qfab’s core interfaces <br>
Most documentation will appear in the BitcodeModule and there is nothing else of interest here
This module is to organize the fabric APIs via a grouping of their corresoding function on the server</div></li><li><div class="item-name"><a class="mod" href="bccontext_error/index.html" title="mod elvwasm::bccontext_error">bccontext_error</a></div></li><li><div class="item-name"><a class="mod" href="bccontext_ext/index.html" title="mod elvwasm::bccontext_ext">bccontext_ext</a></div></li><li><div class="item-name"><a class="mod" href="bccontext_search/index.html" title="mod elvwasm::bccontext_search">bccontext_search</a></div></li><li><div class="item-name"><a class="mod" href="bccontext_struct/index.html" title="mod elvwasm::bccontext_struct">bccontext_struct</a></div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.implement_bitcode_module.html" title="macro elvwasm::implement_bitcode_module">implement_bitcode_module</a></div><div class="desc docblock-short">This macro delivers the required initializtion of the eluvio wasm module
In addition the macro also registers a handler of the form</div></li><li><div class="item-name"><a class="macro" href="macro.implement_ext_func.html" title="macro elvwasm::implement_ext_func">implement_ext_func</a></div></li><li><div class="item-name"><a class="macro" href="macro.register_handlers.html" title="macro elvwasm::register_handlers">register_handlers</a></div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.jpc.html" title="fn elvwasm::jpc">jpc</a></div><div class="desc docblock-short">jpc is the main entry point into a wasm bitcode for the web assembly procedure calls
this function will</div></li><li><div class="item-name"><a class="fn" href="fn.register_handler.html" title="fn elvwasm::register_handler">register_handler</a></div><div class="desc docblock-short">register_handler adjusts the global static call map to associate a bitcode module with a path
this map is used by jpc to implement bitcode calls</div></li></ul></section></div></main></body></html>